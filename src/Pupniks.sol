// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@solady/tokens/ERC721.sol";
import "@solady/auth/Ownable.sol";
import "@solady/utils/ECDSA.sol";
import "@solady/utils/LibString.sol";
import "src/interfaces/IBlast.sol";


error InvalidSignature();
error InvalidHash();
error SaleClosed();
error ContractLocked();
error OutOfStock();
error IncorrectAmountSent();
error NotApprovedOrOwner();
error TokenNotFound();
error NonceAlreadyUsedOrRevoked();
error CannotMintMoreThanMax();
error RedemptionTransferFailed();

contract Pupniks is ERC721, Ownable {
    using LibString for uint256;
    using ECDSA for bytes32;

    event BaseURISet(string URI);
    event ContractURISet(string URI);
    event MetadataLocked();
    event SaleStatusToggled(bool live);
    event SignerAddressSet(address oldSigner, address newSigner);

    uint256 private constant TOTAL_SUPPLY = 3000;
    uint256 private constant PRICE = 0.5 ether;
    uint256 private constant MAX_MINTING_PER_TX = 5;
    IBlast private constant BLAST = IBlast(0x4300000000000000000000000000000000000002);

    /// @dev Map of an address to a bitmap (slot => status)
    mapping(address => mapping(uint256 => uint256)) private _usedNonces;

    /// @dev Base token uri
    string public baseTokenURI;

    /// @dev Contract URI - ERC7572 compliance
    string public contractURI;

    uint256 public amountMinted;
    bool public saleLive;
    bool public locked;

    address private _signerAddress;

    constructor() {
        _initializeOwner(msg.sender);
        BLAST.configureClaimableGas();
        // Commented due to configuration issue on BLAST testnet.
        // BLAST.configureClaimableYield();
    }

    /**
     * @notice Mint function for Pupniks. This function is payable and requires a valid signature from the signer.
     * @dev The signature is generated by signing the hash of the message that includes the sender's address, the quantity of Pupniks to mint, and the nonce.
     * @dev The nonce is used to prevent replay attacks. There is a maximum amout of
     *
     * @param hash The hash of the message that was signed.
     * @param signature The signature of the message.
     * @param nonce The nonce used to sign the message.
     * @param quantity The quantity of Pupniks to mint.
     */
    function mintPupnik(bytes32 hash, bytes calldata signature, uint256 nonce, uint256 quantity) external payable {
        _requireSaleOpen();
        _requireValidSignature(hash, signature, nonce, quantity);
        _useNonce(msg.sender, nonce);

        uint256 currentAmount = amountMinted;

        if (currentAmount + quantity > TOTAL_SUPPLY) {
            revert OutOfStock();
        }
        if (PRICE * quantity != msg.value) {
            revert IncorrectAmountSent();
        }
        if (quantity > MAX_MINTING_PER_TX) {
            revert CannotMintMoreThanMax();
        }

        unchecked {
            amountMinted += quantity;

            for (uint256 i = 1; i <= quantity;) {
                _mint(msg.sender, currentAmount + i);
                ++i;
            }
        }
    }

    /**
     * @notice Redeem function for Pupniks. This function allows the owner to redeem a batch of Pupniks.
     * @notice Redemption sends back the original funding of the Pupniks.
     *
     * @param tokenIds The array of tokenIds to redeem.
     */
    function redeemPupnikBatch(uint256[] calldata tokenIds) external {
        unchecked {
            for (uint256 i = 0; i < tokenIds.length;) {
                _redeemPupnik(tokenIds[i]);
                ++i;
            }
        }
    }

    /**
     * @notice Redeem function for Pupniks. This function allows the owner to redeem a single Pupnik.
     * @notice Redemption sends back the original funding of the Pupnik.
     * @dev This function is slightly more gas efficient and preferred if the user only has one Pupnik to redeem.
     *
     * @param tokenId The tokenId to redeem.
     */
    function redeemPupnik(uint256 tokenId) external {
        _redeemPupnik(tokenId);
    }

    function _redeemPupnik(uint256 tokenId) private {
        if (!_isApprovedOrOwner(msg.sender, tokenId)) {
            revert NotApprovedOrOwner();
        }
        amountMinted -= 1;
        _burn(tokenId);
        
        (bool success, ) = msg.sender.call{value: PRICE, gas: 30_000}("");
        if (!success) {
            revert RedemptionTransferFailed();
        }
    }

    /**
     * @notice Locks metadata from being changed. Only the owner can call this function.
     */
    function lockMetadata() external onlyOwner {
        locked = true;

        emit MetadataLocked();
    }

    /**
     * @notice Toggles the sale status. Only the owner can call this function.
     */
    function toggleSaleStatus() external onlyOwner {
        saleLive = !saleLive;

        emit SaleStatusToggled(saleLive);
    }

    /**
     * @notice Sets the signer address. Only the owner can call this function.
     */
    function setSignerAddress(address addr) external onlyOwner {
        address oldSigner = _signerAddress;
        _signerAddress = addr;

        emit SignerAddressSet(oldSigner, addr);
    }

    /**
     * @notice Sets the contract URI. Only the owner can call this function.
     * @dev This function will revert if the contract is locked.
     */
    function setContractURI(string calldata URI) external onlyOwner {
        _requireNotLocked();
        contractURI = URI;

        emit ContractURISet(URI);
    }

    /**
     * @notice Sets the base token URI. Only the owner can call this function.
     * @dev This function will revert if the contract is locked.
     */
    function setBaseURI(string calldata URI) external onlyOwner {
        _requireNotLocked();
        baseTokenURI = URI;

        emit BaseURISet(URI);
    }

    /**
     * @notice Withdraws any claimable yield from the contract. Only the owner can call this function.
     */
    function withdrawYield() external onlyOwner {
        if (BLAST.readClaimableYield(address(this)) > 0) {
            BLAST.claimAllYield(address(this), owner());
        }
    }

    /**
     * @notice Withdraws any claimable gas from the contract. Only the owner can call this function.
     */
    function withdrawGas() external onlyOwner {
        BLAST.claimAllGas(address(this), owner());
    }

    /**
     * @notice Returns the amount of claimable yield for the contract.
     */
    function claimableYield() external view returns (uint256 yield) {
        yield = BLAST.readClaimableYield(address(this));
    }

    /**
     * @notice Returns the amount of claimable gas for the contract.
     */
    function claimableGas() external view returns (uint256 etherBalance) {
        (, etherBalance,,) = BLAST.readGasParams(address(this));
    }

    /**
     * @notice Returns the token URI for a given tokenId.
     * @dev This function will revert if the token dZoes not exist.
     *
     * @param tokenId The tokenId to get the URI for.
     * @return uri The token URI.
     */
    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory uri) {
        if (!_exists(tokenId)) {
            revert TokenNotFound();
        }
        uri = string(abi.encodePacked(baseTokenURI, tokenId.toString()));
    }

    /**
     * @notice Returns the amount of Pupniks that are currently minted
     * @return amount The amount of Pupniks that are currently minted.
     */
    function getAmountMinted() external view returns (uint256 amount) {
        amount = amountMinted;
    }

    /**
     * @notice Returns the name of the contract
     * @return name_ The contract name.
     */
    function name() public pure override returns (string memory name_) {
        name_ = "Pupniks";
    }

    /**
     * @notice Returns the symbol of the contract
     * @return symbol_ The contract symbol.
     */
    function symbol() public pure override returns (string memory symbol_) {
        symbol_ = "PUPNIK";
    }

    /**
     * @notice Returns the price of a single Pupnik.
     * @return price The price of a single Pupnik.
     */
    function getPrice() external pure returns (uint256 price) {
        price = PRICE;
    }

    /**
     * @notice Returns the total supply of Pupniks.
     * @return supply The total supply of Pupniks.
     */
    function getTotalSupply() external pure returns (uint256 supply) {
        supply = TOTAL_SUPPLY;
    }

    /**
     * @notice Returns if a nonce is valid for a given address.
     *
     * @param tokenOwner The address to check the nonce for.
     * @param nonce The nonce to check.
     *
     * @return isValid True if the nonce is valid, false otherwise.
     */
    function isValidNonce(address tokenOwner, uint256 nonce) external view returns (bool isValid) {
        isValid = ((_usedNonces[tokenOwner][uint248(nonce >> 8)] >> uint8(nonce)) & 1) == 0;
    }

    function _requireValidSignature(bytes32 hash, bytes calldata signature, uint256 nonce, uint256 quantity)
        private
        view
    {
        if (_signerAddress != hash.recover(signature)) {
            revert InvalidSignature();
        }

        bytes32 localHash = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(msg.sender, quantity, nonce))
            )
        );

        if (localHash != hash) {
            revert InvalidHash();
        }
    }

    function _requireSaleOpen() private view {
        if (!saleLive) {
            revert SaleClosed();
        }
    }

    function _requireNotLocked() private view {
        if (locked) {
            revert ContractLocked();
        }
    }

    function _useNonce(address account, uint256 nonce) internal {
        unchecked {
            if (
                uint256(_usedNonces[account][uint248(nonce >> 8)] ^= (1 << uint8(nonce))) & (1 << uint8(nonce))
                    == 0
            ) {
                revert NonceAlreadyUsedOrRevoked();
            }
        }
    }
}
